<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta name="theme-color" content="#000000" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <script type="text/javascript" src="https://static.sketchfab.com/api/sketchfab-viewer-1.5.1.js"></script>
    <title>UNCUT // BK</title>
  </head>
  <body>
    <!-- <div id="root"></div> -->
    <div class='iframe-container'>
      <iframe src="" id="api-frame" allow="autoplay; fullscreen; vr" allowvr allowfullscreen mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>
      <form class="options"></form>
    </div>
    <script type='text/javascript'>
      const iframe = document.getElementById('api-frame');
      const DEFAULT_URLID = 'bf8ed63c2de24613a564f91c125c84dd';
      const DEFAULT_PREFIX = 'hello-bryan ';

      const CONFIG = {
        urlid: DEFAULT_URLID,
        prefix: DEFAULT_PREFIX
      };
      //  opt-<majorAttr>-<minorAttr>-<v#> 
      const ATTR_DISPLAY_CONFIG = {
        body: {
          label: 'Size',
          versions: {

          },
          isMajorAttr: true,
        },
        mouth: {
          label: 'Mouth',
          versions: {

          }
        }
      };

      const ATTR_ORDER = [
        'body',
        'mouth'
      ];

      const Configurator = {
          api: null,
          config: null,
          options: {},
          /**
           * Initialize viewer
           */
          init: function (config, iframe) {
              this.config = config;
              var client = new Sketchfab(iframe);
              client.init(config.urlid, {
                  ui_infos: 0,
                  ui_controls: 0,
                  graph_optimizer: 0,
                  success: (api) => {
                    api.start();
                    api.addEventListener('viewerready', () => {
                      this.api = api;
                      this.initializeOptions(() => {
                          console.log('Found the following options:', this.modelOpts);
                          // this.selectOption(0); //instantiate the visible model
                          // instantiate with default values
                          UI.init(this.config, this.modelOpts);
                      });
                    });
                  }, 
                  error: () => { console.log('Viewer error') }
              });
          },
          /**
           * Initialize options from scene
           */
          initializeOptions: (callback) => {
            this.api.getNodeMap((err, nodes) => {
              console.log('get node map results', nodes)
              if (err) {
                console.error(err);
                return;
              }

              Object.values(nodes).forEach((node) => {
                if (!node.name && !['Geometry', 'Group'].includes(node.type)) return;
                const [opt, size, name, version] = node.name.split('-');

                const newOption = {
                  id: node.instanceID,
                  name: node.name,
                  selected: false
                }

                if (!size || !name || !version) return;
                if (!this.modelOpts[size]) this.modelOpts[size] = {};
                if (!this.modelOpts[size][name]) this.modelOpts[size][name] = {};

                this.modelOpts[size][name][version] = newOption;
              });
              callback();
            });
          },
          /**
           * Select option to show
           */
          selectOption: (minorAttr, version) => {
            var options = this.modelOpts;
            console.log('options ===', this.modelOpts);
            // look up minor attr in display config
            // if major attr -> swap everything
            // if !major attr
              // look up minor attr and iterate over versions
              // if version === input version set selected to true, turn on option on api
              // else set selected to false, turn off option on api



            // for (var i = 0, l = options.length; i < l; i++) {
            //   if (i === index) {
            //       options[i].selected = true;
            //       this.api.show(options[i].id);
            //   } else {
            //       options[i].selected = false;
            //       this.api.hide(options[i].id);
            //   }
            // }
          }
      }


      var UI = {
          config: null,
          options: null,
          init: (config, options) => {
            this.config = config;
            this.modelOpts = options;
            this.el = document.querySelector('.options');
            this.render();

            this.el.addEventListener('change', function (e) {
                e.preventDefault();
                console.log('here', this.el.elements);
                // var index = parseInt(this.el.elements['color'].value, 10);
                // determine minorAttr and version via element that changed
                this.select(minorAttr, version);
            });
          },
          select: (minorAttr, version) => {
              Configurator.selectOption(minorAttr, version);
              this.render();
          },
          render: () => { this.renderRadio(); },
          /**
           * Render options as multiple `<input type="radio">`
           */
          renderRadio: () => {
            // map over opt order
            ATTR_ORDER.forEach((minorAttr) => {
              // look up model opts by major/minor attr this.modelOptions, 
              // const modelOptions = this.modelOpts
            })
            // if !modelOption return
            // look up minor attr display in attr_display_config
            // build label
            // iterate over attr_display opts and check model options for opt
            // if !minor_attr opt return
            // produce a radio button for each 
            // if opt isSelected then make it checked


              // var html = this.modelOpts.map(function (option, i) {
              //     var checkedState = option.selected ? 'checked="checked"' : '';
              //     var className = option.name.replace(this.config.prefix, '');
              //     return [
              //         '<label class="options__option">',
              //         '<input type="radio" name="color" value="' + i + '" ' + checkedState + '>',
              //         '<span class="' + className + '">' + option.name + '</span>',
              //         '</label>'
              //     ].join('');
              // }.bind(this)).join('');
              // this.el.innerHTML = html;
          },
      }

      Configurator.init(CONFIG, iframe);


    </script>
  </body>
</html>
