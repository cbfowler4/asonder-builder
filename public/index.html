<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta name="theme-color" content="#000000" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <script type="text/javascript" src="https://static.sketchfab.com/api/sketchfab-viewer-1.5.1.js"></script>
    <title>UNCUT // BK</title>
  </head>
  <body>
    <!-- <div id="root"></div> -->
    <div class='iframe-container'>
      <iframe src="" id="api-frame" allow="autoplay; fullscreen; vr" allowvr allowfullscreen mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>
      <form class="options"></form>
    </div>
    <script type='text/javascript'>
      const iframe = document.getElementById('api-frame');
      const DEFAULT_URLID = 'bf8ed63c2de24613a564f91c125c84dd';
      const DEFAULT_PREFIX = 'hello-bryan ';

      const CONFIG = {
        urlid: DEFAULT_URLID,
        prefix: DEFAULT_PREFIX
      };

      const Configurator = {
          api: null,
          config: null,
          options: {},
          /**
           * Initialize viewer
           */
          init: function (config, iframe) {
              this.config = config;
              var client = new Sketchfab(iframe);
              client.init(config.urlid, {
                  ui_infos: 0,
                  ui_controls: 0,
                  graph_optimizer: 0,
                  success: function onSuccess(api) {
                      api.start();
                      api.addEventListener('viewerready', function () {
                          this.api = api;
                          this.initializeOptions(function () {
                              console.log('Found the following options:', this.options);
                              // this.selectOption(0); //instantiate the visible model
                              UI.init(this.config, this.options);
                          }.bind(this));
                      }.bind(this));
                  }.bind(this),
                  error: function onError() {
                      console.log('Viewer error');
                  }
              });
          },
          /**
           * Initialize options from scene
           */
          initializeOptions: function initializeOptions(callback) {
            this.api.getNodeMap(function (err, nodes) {
              console.log('get node map results', nodes)
              if (err) {
                  console.error(err);
                  return;
              }

              Object.values(nodes).forEach((node) => {
                if (!node.name && !['Geometry', 'Group'].includes(node.type)) return;
                const [opt, size, name, version] = node.name.split('-');

                const newOption = {
                  id: node.instanceID,
                  name: node.name,
                  selected: false
                }

                if (!size || !name || !version) return;
                if (!this.options[size]) this.options[size] = {};
                if (!this.options[size][name]) this.options[size][name] = {};

                this.options[size][name][version] = newOption;
              });
              callback();
            }.bind(this));
          },
          /**
           * Select option to show
           */
          selectOption: function selectOption(index) {
            var options = this.options;
            console.log('options ===', this.options);
            // for (var i = 0, l = options.length; i < l; i++) {
            //   if (i === index) {
            //       options[i].selected = true;
            //       this.api.show(options[i].id);
            //   } else {
            //       options[i].selected = false;
            //       this.api.hide(options[i].id);
            //   }
            // }
          }
      }


      var UI = {
          config: null,
          options: null,
          init: function init(config, options) {
              this.config = config;
              this.options = options;
              this.el = document.querySelector('.options');
              this.render();

              this.el.addEventListener('change', function (e) {
                  e.preventDefault();
                  console.log('here', this.el.elements);
                  var index = parseInt(this.el.elements['color'].value, 10);
                  this.select(index);
              }.bind(this));
          },
          select: function (index) {
              // Configurator.selectOption(parseInt(index, 10));
              // this.render();
          },
          render: function () { this.renderRadio(); },
          /**
           * Render options as multiple `<input type="radio">`
           */
          renderRadio: function render() {
              // var html = this.options.map(function (option, i) {
              //     var checkedState = option.selected ? 'checked="checked"' : '';
              //     var className = option.name.replace(this.config.prefix, '');
              //     return [
              //         '<label class="options__option">',
              //         '<input type="radio" name="color" value="' + i + '" ' + checkedState + '>',
              //         '<span class="' + className + '">' + option.name + '</span>',
              //         '</label>'
              //     ].join('');
              // }.bind(this)).join('');
              // this.el.innerHTML = html;
          },
          /**
           * Render option as `<select>`
           */
          renderSelect: function () {
              var html = this.options.map(function (option, i) {
                  var checkedState = option.selected ? 'selected="selected"' : '';
                  return [
                      '<option value="' + i + '" ' + checkedState + '>',
                      option.name,
                      '</option>',
                  ].join('');
              }).join('');
              this.el.innerHTML = '<select name="color">' + html + '</select>';
          }
      }

      Configurator.init(CONFIG, iframe);


    </script>
    <!-- <script type="text/javascript">
      var iframe = document.getElementById( 'api-frame' );
      var uid = '7w7pAfrCfjovwykkEeRFLGw5SXS';
  
      // By default, the latest version of the viewer API will be used.
      var client = new Sketchfab( iframe );
  
      // Alternatively, you can request a specific version.
      // var client = new Sketchfab( '1.5.1', iframe );
  
      client.init( uid, {
          success: function onSuccess( api ){
              api.start();
              api.addEventListener( 'viewerready', function() {
  
                  // API is ready to use
                  // Insert your code here
                  console.log( 'Viewer is ready' );
  
              } );
          },
          error: function onError() {
              console.log( 'Viewer error' );
          }
      } );
      </script> -->
  </body>
</html>
